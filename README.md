# bison構文解析を用いたラムダ計算機(未完成)

# 概要

C言語のパーサージェネレーターBisonを用いて、ラムダ計算式の構文解析器を作成する。

# 動機

以前Pythonでラムダ計算機を作成したことがあったが、その時の構文解析は文字を読み込んではプログラムの状態を変えるというプログラムを一から作成したので、許容できる構文の範囲がわからなかった。そこで、Bisonを持ちてBNF記法で指定するとで、正しい文法とそうでない文法がはっきりわかるようなラムダ計算機を作りたいと思ったからである。

# プログラムの目的

ラムダ計算式の形をした入力の構文木を解析し、関数適用、関数抽象の構造に対応した木構造を生成する。

# ラムダ計算のBNFを考える

以下のレポートでは、表記の簡潔さから文字'$\lambda$'を'@'として表記することがある。

## ラムダ計算の理論的な定義

ラムダ計算式を生成する構文をBNF記法で表すことを考える。数学的な観点からよく知られている規則は以下のようなものである(横内 1994)。

```
<式> ::= <変数> | <関数適用> | <抽象化>
<関数適用> ::=  <式> <式> 
<抽象化> ::= "λ" <変数> "." <式>
```

上記のBNF記法では、<式>はラムダ計算の式を表す。一番上は式は変数、関数適用、または抽象化のいずれかによって構成されることを表す。

<関数適用>は関数適用を表す。関数適用は、2つの式を並列して書いたものである。

<抽象化>はラムダ抽）を表す。抽象化は、ラムダ記号 λ、変数、ピリオド .、そして式からなる形式 λ変数.式 として表現される。

この式は理論的に解析する上では問題がないが、今回のように実際にプログラムにする場合、括弧について制約がなく、演算子の左右の結合優先度も定義されていないことから、例えば以下のような式でshift/reduce conflictが起きてしまう。また、以下の例のようなラムダ抽象が2回重なった時の関数の縮約は実装されていない。
```
    abc
    @x.@y.z = @xy.z
```

## 今回のラムダ計算機への要請

そこで、今回のラムダ計算機では0として以下のような構文の柔軟性が要請される。

- 式の外側にいくつ括弧を施しても式の役割は変わらない。(例1)
- 演算の結合優先度は、関数適用>ラムダ抽象である。例2
- ラムダ文字や、文字同士の関数適用などで、関数適用の区切りがわかる場合は括弧を必要としない。以下の例3.
- ラムダ抽象が複数重なった場合、縮約できる。(例4)

例
```
1: (((x))) = x
2: @a.b@c.d = @a.(b@c.d)
3:  y@x.x = y(@x.x)
4: @xy.z = @x.@y.z
```

## 要請を満たすBNF記法

上で述べた要請を満たすようなラムダ計算の構文木を考えたところ、以下のようなものが得られた。

```
<expr> ::= <abst> | <appl> | <vars>

<abst> ::= '(' <abst> ')' 
    | '@' <abstvars> '.' <abst> 
    | '@' <abstvars> '.' <appl> 
    | '@' <abstvars> '.' <vars>

<abstvars> ::= VAR 
    | <abstvars> VAR

<appl> ::= '(' <appl> ')' 
    | <vars> <vars> 
    | <abst> <abst> 
    | <appl> <abst> 
    | '(' <abst> ')' <appl> 
    | <vars> '(' <appl> ')' 
    | <vars> <abst> 
    | <appl> <vars> 
    | '(' <abst> ')' <vars>

<vars> ::= VAR | '(' <vars> ')'
```

また、それぞれのsymbolのsemanticsは以下のよう。特に、式の外側の括弧を取り除いたときに最後に行われた演算に注目している。

- expr: ラムダ計算の式を表していする。
 
- abst: ラムダ抽象の式の外側に0個以上の括弧を施したもの。
 
- appl: 関数適用の式の外側に0個以上の括弧を施したもの。
 
- abstvars: ラムダ抽象の引数が1つ以上連結した状態を表す。
 
- vars: ラムダ抽象の変数以外の場所で、変数1文字とそれに0個以上の括弧が施されている状態を表す。
- VAR: 実際入力された一文字の変数を表す。
 
 
次にそれぞれの書き換えの意味を説明する。

    exprの書き換え: このBNFは式の最後に行われた演算に注目していることから、ラムダ計算式式はラムダ抽象の式、関数適用の式、文字のいずれかであり、このような規則になる。

    abstの書き換え: abstの意味は「ラムダ抽象に0個以上の括弧を施したもの」であるから、abstに括弧を施したものとラムダ抽象の形状をしたものがabstである

    applの書き換え: applの意味は「ラムダ抽象に0個以上の括弧を施したもの」であるから、applに括弧を施したものと関数適用を施したものがapplである。また、関数適用においては、左右にどのような型の記号がくるかによって、括弧が必要かそうでないかが分かれることから、以下のような表を作成し、左右の括弧の有無を調べて構成した。

|      | abst     | appl       | vars     |
| ---- | -------- | ---------- | -------- |
| abst | 必要なし | 右に必要   | 右に必要 |
| appl | 必要なし | 双方に必要 | 必要なし |
| vars | 必要なし | 必要なし   | 必要なし |
    
    advarsの書き換え: これは、ラムダ抽象が連続したときの縮約規則を実現する物である。
    
    varsの書き換え: これは文字列に0個以上の括弧を施したものであるから、それに基づいて書き換え規則を構成した。


## 各書き換え規則へのsemanticsの定義

関数適用においては、演算子ノードを定義しその子ノードとしてオペランドをつけた。括弧を外側につけるような演算においてはラムダ計算式の構造は変化しないので木構造はそのままにした。一方、ラムダ抽象においては、縮約規則の影響で構文の構造とラムダ計算の構造は一致しない。そこで、ラムダ抽象の縮約規則に、左のオペランドの木構造の末尾に右のオペランドの木構造をつなげるという意味にすることですることで、縮約が展開されたときのラムダ計算の木構造と一致することにした。

## ラムダ計算機を構成しての考察

### 縮約規則への対応による意味の変化

    今回のプログラムでは、ラムダ抽象が連続した場合に以下のように縮約を可能にした。しかし、この構文木を直接実装しようとすると1文字以上の文字列を短い文字列に変換することになり、文脈自由文法から外れてしまう。そこで、見かけ上の構文を優先させてadstversなどの型を定義することで文脈自由文法の中に納めたが、これによってラムダ計算式上の構文木と実際の式の構造の構文木の対応が取れなくなってしまうことがわかった。

```
@x.y.z = @xy.z
```

### Bisonを用いてプログラムをすることの利点

    まず、Bisonを利用したパーサーの作成は、逐次処理ではない記法(BNF記法)から逐次的な処理であるC言語のコードを生成できたことから、自分で新たな言語を生成する際にとても便利だと思った。
    
    他には、Bisonのコンパイラにはshift/reduce conflictが起きた際にその例を表示するデバッガや、構文解析の過程をチャート法で示す機能がついており、自分の構文規則の曖昧さを調べながら進むことができたことは、Bisonの利点だと思った。
    
### その他の論点

    今回のレポートでは構文の解析にとどまり、reductionまで行うことができなかった。以前pythonでは実装したことがあるので、これをC言語に直して実装したいと思う。
    
    今回のラムダ計算機に用いたBNF記法は、ラムダ抽象の連続による縮約規則を、書き換え規則の意味を特殊にすることで文脈自由文法の範囲に落とし込むことができた。これを用いれば、他の文脈依存文法の解析においても文脈自由文法の問題に落とし込むことができないかと思った。

    今回制作したラムダ計算機には解析できない例が発生してしまった(以下)。しかし、BNF記法の構文規則に戻ると、これは確かに受理させるべき構文である。この原因を考えたい。

```
(@x.x)@y.y
エラー: 意図しない文字列の終端。'('か'@'が来ないといけない。
```

# 参考文献

Bison 3.8.1. https://www.gnu.org/software/bison/manual/bison.html

Roberto M. Amadio, Pierre-Louis Curien,Cambridge ; New York : Cambridge University Press, Domains and lambda-calculi.(1998)

横内寛文, プログラム意味論, 共立出版, 1994.

# ファイル構成

- lambda-file: ラムダ計算をファイルから入力可能。
```
./a.out <ファイル名>
```
改行などの実装が終わっていない。

- only-plus-file: 足し算の演算のみを行うプログラムonly-plusに、ファイルからの入力が可能になった。ファイルの読み込みは以下のよう
```
./a.out <ファイル名>
```

- flex-file-io: flexのdemo。inputファイルの構文を解析しoutputに出す。

- lambda-tree: ラムダ計算式 -> 構文木の完成形
できる計算
```
\ab.c : 複数抽象
\a.bcd : 抽象の括弧省略
\x.y\z.q : 適用の括弧省略
((\x.y)) : 抽象、適用に対する意味の無い括弧の連続
```

できない計算
```
((x)) : 定数に対する意味の無い括弧の連続(将来、importをファイル結合で実装したいなら必要かも)
```

- lambda-tree-uni-var: 変数の連続applyに括弧はいらないが、abtractの際に変数は1文字しか置くことができない。

-strict-lambda-bin-tree: 定数、変数同士のapplyでも括弧が必要なラムダ式

- make-tree: (,+,) を用いた構文から、構造体で定義されたノード同士の参照関係からなる2分木を生成する。
 


- plus-parser: `(+)`を用いて書かれた式の構造を解析し、`[,]`に変換する
例
```
input: (1+(2+3))
output: [1,[2,3]]
```

- only-plus: bison exampleのcalc.yから間引いて、数値+数値、の形をしたコードのみ計算するようにしたもの。.gvファイルを、graphvizで見るために単純なコードにした。これを改変してstring+stringで文字列を結合するようにしたのが、plus-to-string。

- plus-to-string: only-plusを改変して、string+stringを入力したときのみこれらをcatして返すコード

- rpn: RPN(逆ポーランド記法)を処理するbison examplesのコード

- tree.c: 2分木アルゴリズム。ノードを構造体で管理している。

# 考えられる原因とデバッグ方法

yylexエラー
- 正しく形態素に区切れているか -> 文字数のカウントや、型をprintして確かめる。

構文エラー
- %varboseなどを用いてどこの入力がsyntax errorだったかを解析する
- 数値などの単純なtoken(終端記号)を持つ、同じ構造の文法規則を作り、--graphを指定してコンパイルして、.gvファイルのオートマトンを比較する。
